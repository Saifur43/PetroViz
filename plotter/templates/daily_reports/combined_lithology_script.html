{% if prognosis_segments or lithology_segments %}
<script>
(function(){
    const wrap = document.getElementById('combined-lithology-wrap');
    const prognosisBar = document.getElementById('prognosis-bar-combined');
    const lithologyBar = document.getElementById('lithology-bar-combined');
    const ticks = document.getElementById('combined-ticks');
    if (!wrap) return;
    
    // Get combined range for positioning
    const ticksMin = ticks ? parseFloat(ticks.getAttribute('data-min')) || 0 : 0;
    const ticksMax = ticks ? parseFloat(ticks.getAttribute('data-max')) || 0 : 0;
    const combinedTotal = Math.max(ticksMax, 1e-6);
    
    // Position segments based on absolute depth values
    function positionSegments(bar, isLithology) {
        if (!bar) return;
        
        // Ensure bar is positioned relatively
        bar.style.position = 'relative';
        
        // Get all segments (including gaps and containers)
        const allSegments = bar.querySelectorAll('.prognosis-segment, .lithology-segment-container');
        allSegments.forEach(seg => {
            const from = parseFloat(seg.getAttribute('data-from'));
            const to = parseFloat(seg.getAttribute('data-to'));
            
            if (!isNaN(from) && !isNaN(to)) {
                // Calculate position based on absolute depth within combined range
                const topPct = (from / combinedTotal) * 100.0;
                const bottomPct = (to / combinedTotal) * 100.0;
                const calculatedHeight = Math.max(bottomPct - topPct, 0.1); // Minimum 0.1% to ensure visibility
                
                // Use absolute positioning to place segments at correct depths
                seg.style.position = 'absolute';
                seg.style.top = topPct + '%';
                seg.style.height = calculatedHeight + '%';
                seg.style.width = '100%';
                seg.style.left = '0';
                
                // Set color if it's a simple segment (not a container)
                if (!seg.classList.contains('lithology-segment-container')) {
                    const color = seg.getAttribute('data-color');
                    const lithology = seg.getAttribute('data-lithology');
                    if (color) {
                        seg.style.background = color;
                        // Apply alteration pattern (sand with lines)
                        if (lithology === 'alteration') {
                            seg.style.backgroundImage = 'repeating-linear-gradient(45deg, #FFD700, #FFD700 4px, #FFA500 4px, #FFA500 8px)';
                        }
                    }
                }
            }
        });
        
        // Handle lithology sub-segments (horizontal breakdown)
        if (isLithology) {
            lithologyBar.querySelectorAll('.lithology-segment-container').forEach(container => {
                container.style.display = 'flex';
                container.style.flexDirection = 'row';
                // Position is already set above
                
                const subSegments = container.querySelectorAll('.lithology-sub-segment');
                subSegments.forEach(subSeg => {
                    const subWidth = parseFloat(subSeg.getAttribute('data-height'));
                    if (!isNaN(subWidth)) {
                        subSeg.style.width = subWidth + '%';
                        subSeg.style.height = '100%';
                        subSeg.style.flexShrink = '0';
                    }
                    const color = subSeg.getAttribute('data-color');
                    const type = subSeg.getAttribute('data-type');
                    if (color) {
                        subSeg.style.background = color;
                        // Apply alteration pattern (sand with lines)
                        if (type === 'alteration') {
                            subSeg.style.backgroundImage = 'repeating-linear-gradient(45deg, #FFD700, #FFD700 4px, #FFA500 4px, #FFA500 8px)';
                        }
                    }
                });
            });
            
            // Position gas show markers
            lithologyBar.querySelectorAll('.gas-show-marker').forEach(marker => {
                const depth = parseFloat(marker.getAttribute('data-depth'));
                if (!isNaN(depth)) {
                    const topPct = (depth / combinedTotal) * 100.0;
                    marker.style.position = 'absolute';
                    marker.style.top = topPct + '%';
                    marker.style.left = '50%';
                    marker.style.transform = 'translate(-50%, -50%)';
                    marker.style.width = '8px';
                    marker.style.height = '8px';
                    marker.style.borderRadius = '50%';
                    marker.style.background = '#ff6b35';
                    marker.style.border = '2px solid #fff';
                    marker.style.boxShadow = '0 0 4px rgba(255, 107, 53, 0.8), 0 0 8px rgba(255, 107, 53, 0.4)';
                    marker.style.zIndex = '5';
                    marker.style.cursor = 'pointer';
                }
            });
        }
    }
    
    // Position segments for both bars
    positionSegments(prognosisBar, false);
    positionSegments(lithologyBar, true);

    function computeBarHeight() {
        try {
            const card = wrap.closest('.card');
            const rectTop = card.getBoundingClientRect().top;
            const topOffset = Math.max(rectTop, 0);
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            const targetHeight = Math.max(viewportHeight - 24 - (rectTop - topOffset), 280);
            
            if (prognosisBar) prognosisBar.style.height = targetHeight + 'px';
            if (lithologyBar) lithologyBar.style.height = targetHeight + 'px';
            if (ticks) ticks.style.height = targetHeight + 'px';
        } catch(e) { /* noop */ }
    }

    function niceStep(max) {
        if (!max || max <= 0) return 50;
        const raw = max / 12;
        const candidates = [10, 20, 25, 50, 100, 200, 250, 500, 1000];
        let best = candidates[0];
        for (const c of candidates) {
            if (raw <= c) { best = c; break; }
            best = c;
        }
        return best;
    }

    function buildTicks() {
        if (!ticks) return;
        const min = parseFloat(ticks.getAttribute('data-min')) || 0;
        const max = parseFloat(ticks.getAttribute('data-max')) || 0;
        const step = niceStep(max);
        const labels = [];
        const start = Math.max(0, Math.floor(min / step) * step);
        for (let v = start; v <= max; v += step) labels.push(v);
        if (labels[0] !== 0) labels.unshift(0);
        if (labels[labels.length - 1] !== max) labels.push(max);
        ticks.innerHTML = '';
        labels.forEach((value, idx) => {
            const row = document.createElement('div');
            row.className = 'prognosis-tick';
            const line = document.createElement('span');
            line.className = 'prognosis-tick-line';
            const label = document.createElement('span');
            label.textContent = value + ' m';
            row.appendChild(line);
            row.appendChild(label);
            ticks.appendChild(row);
        });
    }

    function renderLatestDepthMarker() {
        const latestAttr = (prognosisBar || lithologyBar)?.getAttribute('data-latest-depth');
        if (!latestAttr || !ticks) return;
        const latest = parseFloat(latestAttr);
        const max = parseFloat(ticks.getAttribute('data-max')) || 0;
        if (!max || isNaN(latest)) return;
        const clamped = Math.max(0, Math.min(latest, max));
        const pct = (clamped / max) * 100;

        // Add marker to both bars if they exist
        [prognosisBar, lithologyBar].forEach(bar => {
            if (!bar) return;
            let marker = bar.querySelector('.prognosis-marker');
            let label = bar.querySelector('.prognosis-marker-label');
            if (!marker) {
                marker = document.createElement('div');
                marker.className = 'prognosis-marker';
                bar.appendChild(marker);
            }
            if (!label) {
                label = document.createElement('div');
                label.className = 'prognosis-marker-label';
                bar.appendChild(label);
            }
            marker.style.top = pct + '%';
            label.style.top = pct + '%';
            label.textContent = 'Latest: ' + clamped.toFixed(1) + ' m';
        });
    }

    computeBarHeight();
    buildTicks();
    renderLatestDepthMarker();
    window.addEventListener('resize', () => {
        computeBarHeight();
        renderLatestDepthMarker();
    });
})();
</script>
{% endif %}

