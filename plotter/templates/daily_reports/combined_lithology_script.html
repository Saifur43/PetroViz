{% if prognosis_segments or lithology_segments %}
<script>
(function(){
    const wrap = document.getElementById('combined-lithology-wrap');
    const prognosisBar = document.getElementById('prognosis-bar-combined');
    const lithologyBar = document.getElementById('lithology-bar-combined');
    const ticks = document.getElementById('combined-ticks');
    if (!wrap) return;
    
    // Handle spacers and segments for prognosis bar
    if (prognosisBar) {
        prognosisBar.querySelectorAll('.prognosis-spacer, .prognosis-segment').forEach(el => {
            const h = parseFloat(el.getAttribute('data-height'));
            if (!isNaN(h)) el.style.height = h + '%';
            const color = el.getAttribute('data-color');
            if (color) el.style.background = color;
        });
    }
    
    // Handle spacers and gap segments for lithology bar
    if (lithologyBar) {
        lithologyBar.querySelectorAll('.prognosis-spacer, .prognosis-segment.lithology-gap').forEach(el => {
            const h = parseFloat(el.getAttribute('data-height'));
            if (!isNaN(h)) el.style.height = h + '%';
            const color = el.getAttribute('data-color');
            if (color) el.style.background = color;
        });
        
        // Handle lithology segments with breakdown
        lithologyBar.querySelectorAll('.lithology-segment-container').forEach(container => {
            const containerHeight = parseFloat(container.getAttribute('data-height'));
            if (!isNaN(containerHeight)) {
                container.style.height = containerHeight + '%';
                container.style.display = 'flex';
                container.style.flexDirection = 'row';
                container.style.position = 'relative';
                container.style.width = '100%';
            }
            
            // Set up sub-segments (horizontal layout)
            const subSegments = container.querySelectorAll('.lithology-sub-segment');
            subSegments.forEach(subSeg => {
                const subWidth = parseFloat(subSeg.getAttribute('data-height')); // Using height attribute for width percentage
                if (!isNaN(subWidth)) {
                    subSeg.style.width = subWidth + '%';
                    subSeg.style.height = '100%';
                    subSeg.style.flexShrink = '0';
                }
                const color = subSeg.getAttribute('data-color');
                if (color) subSeg.style.background = color;
            });
        });
    }

    function computeBarHeight() {
        try {
            const card = wrap.closest('.card');
            const rectTop = card.getBoundingClientRect().top;
            const topOffset = Math.max(rectTop, 0);
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            const targetHeight = Math.max(viewportHeight - 24 - (rectTop - topOffset), 280);
            
            if (prognosisBar) prognosisBar.style.height = targetHeight + 'px';
            if (lithologyBar) lithologyBar.style.height = targetHeight + 'px';
            if (ticks) ticks.style.height = targetHeight + 'px';
        } catch(e) { /* noop */ }
    }

    function niceStep(max) {
        if (!max || max <= 0) return 50;
        const raw = max / 12;
        const candidates = [10, 20, 25, 50, 100, 200, 250, 500, 1000];
        let best = candidates[0];
        for (const c of candidates) {
            if (raw <= c) { best = c; break; }
            best = c;
        }
        return best;
    }

    function buildTicks() {
        if (!ticks) return;
        const min = parseFloat(ticks.getAttribute('data-min')) || 0;
        const max = parseFloat(ticks.getAttribute('data-max')) || 0;
        const step = niceStep(max);
        const labels = [];
        const start = Math.max(0, Math.floor(min / step) * step);
        for (let v = start; v <= max; v += step) labels.push(v);
        if (labels[0] !== 0) labels.unshift(0);
        if (labels[labels.length - 1] !== max) labels.push(max);
        ticks.innerHTML = '';
        labels.forEach((value, idx) => {
            const row = document.createElement('div');
            row.className = 'prognosis-tick';
            const line = document.createElement('span');
            line.className = 'prognosis-tick-line';
            const label = document.createElement('span');
            label.textContent = value + ' m';
            row.appendChild(line);
            row.appendChild(label);
            ticks.appendChild(row);
        });
    }

    function renderLatestDepthMarker() {
        const latestAttr = (prognosisBar || lithologyBar)?.getAttribute('data-latest-depth');
        if (!latestAttr || !ticks) return;
        const latest = parseFloat(latestAttr);
        const max = parseFloat(ticks.getAttribute('data-max')) || 0;
        if (!max || isNaN(latest)) return;
        const clamped = Math.max(0, Math.min(latest, max));
        const pct = (clamped / max) * 100;

        // Add marker to both bars if they exist
        [prognosisBar, lithologyBar].forEach(bar => {
            if (!bar) return;
            let marker = bar.querySelector('.prognosis-marker');
            let label = bar.querySelector('.prognosis-marker-label');
            if (!marker) {
                marker = document.createElement('div');
                marker.className = 'prognosis-marker';
                bar.appendChild(marker);
            }
            if (!label) {
                label = document.createElement('div');
                label.className = 'prognosis-marker-label';
                bar.appendChild(label);
            }
            marker.style.top = pct + '%';
            label.style.top = pct + '%';
            label.textContent = 'Latest: ' + clamped.toFixed(1) + ' m';
        });
    }

    computeBarHeight();
    buildTicks();
    renderLatestDepthMarker();
    window.addEventListener('resize', () => {
        computeBarHeight();
        renderLatestDepthMarker();
    });
})();
</script>
{% endif %}

